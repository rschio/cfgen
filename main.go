package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"unicode"
	"unicode/utf8"
)

var (
	fname      = flag.String("f", "", "file name")
	structName = flag.String("s", "", "model struct")
)

func main() {
	flag.Parse()
	if *fname == "" {
		log.Print("flag -f needed")
		flag.Usage()
		os.Exit(1)
	}
	if *structName == "" {
		log.Print("flag -s needed")
		flag.Usage()
		os.Exit(1)
	}
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, *fname, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	info := types.Info{
		Defs: make(map[*ast.Ident]types.Object),
	}
	conf := types.Config{
		Importer: importer.Default(),
	}
	pkg, err := conf.Check("", fset, []*ast.File{f}, &info)
	if err != nil {
		log.Fatal(err)
	}
	g := &Generator{
		pkg:        pkg,
		structName: *structName,
		imports:    make(map[string]*types.Package),
		g:          &GenFile{},
	}

	var strct *types.Struct
	for d, v := range info.Defs {
		if d.Name != g.structName {
			continue
		}
		strct = v.Type().Underlying().(*types.Struct)
		break
	}
	if strct == nil {
		log.Fatalf("struct %q not found", g.structName)
	}

	for i := 0; i < strct.NumFields(); i++ {
		f := strct.Field(i)
		field := Field{
			name: f.Name(),
			typ:  g.typNow,
			zero: g.zero(f.Type()),
		}
		g.fields = append(g.fields, field)
	}

	source := g.generate()
	source, err = format.Source(source)
	if err != nil {
		log.Fatalf("failed to format source: %v", err)
	}
	fmt.Printf("%s", source)

}

type GenFile struct {
	buf bytes.Buffer
}

func (g *GenFile) P(v ...interface{}) {
	for _, x := range v {
		fmt.Fprint(&g.buf, x)
	}
	fmt.Fprintln(&g.buf)
}

type Field struct {
	name string
	typ  string
	zero string
}

type Generator struct {
	pkg        *types.Package
	structName string
	imports    map[string]*types.Package
	rec        int // recursion
	typNow     string
	fields     []Field
	g          *GenFile
}

func (g *Generator) generate() []byte {
	g.g.P("// Code generated by cfgen. DO NOT EDIT.")
	g.g.P()
	// TODO: change package name.
	g.g.P("package ", "generated")
	g.g.P()
	g.g.P("import (")
	for _, pkg := range g.imports {
		g.g.P(fmt.Sprintf("%q", pkg.Path()))
	}
	g.g.P(")")
	g.g.P()
	g.g.P("var (")
	for _, f := range g.fields {
		g.g.P(fmt.Sprintf("default%s %s", f.name, f.typ))
	}
	g.g.P(")")
	g.g.P()
	g.g.P("type base struct{}")
	g.g.P()
	for _, f := range g.fields {
		g.g.P(fmt.Sprintf("func (base) %s() %s { return default%s }", f.name, f.typ, f.name))
	}
	g.g.P()
	g.g.P(fmt.Sprintf("func New() %s {", g.structName))
	g.g.P("return base{}")
	g.g.P("}")
	g.g.P()
	g.g.P(fmt.Sprintf("type %s interface {", g.structName))
	for _, f := range g.fields {
		g.g.P(fmt.Sprintf("%s() %s", f.name, f.typ))
	}
	g.g.P("}")
	g.g.P()
	g.set()
	return g.g.buf.Bytes()
}

func (g *Generator) set() {
	for _, f := range g.fields {
		isLower := false
		r, size := utf8.DecodeRuneInString(f.name)
		l := unicode.ToLower(r)
		if r == l {
			isLower = true
		}
		field := string(l) + f.name[size:]
		if isLower {
			field = "_" + field
		}

		g.g.P(fmt.Sprintf("type cfg%s struct {", f.name))
		g.g.P(g.structName)
		g.g.P(fmt.Sprintf("%s %s", field, f.typ))
		g.g.P("}")
		g.g.P()
		g.g.P(fmt.Sprintf("func (cfg cfg%s) %s() %s {", f.name, f.name, f.typ))
		g.g.P(fmt.Sprintf("return cfg.%s", field))
		g.g.P("}")
		g.g.P()
		g.g.P(fmt.Sprintf("func Set%s(cfg %s, %c %s) %s {", f.name, g.structName, l, f.typ, g.structName))
		g.g.P(fmt.Sprintf("return cfg%s{", f.name))
		g.g.P(fmt.Sprintf("%s: cfg,", g.structName))
		g.g.P(fmt.Sprintf("%s: %c,", field, l))
		g.g.P("}")
		g.g.P("}")
	}
}

func (g *Generator) zero(typ types.Type) string {
	g.rec++
	defer func() { g.rec-- }()
	switch t := typ.(type) {
	case *types.Basic:
		g.typNow = t.Name()
		return t.Name()
	case *types.Named:
		name := ""
		pkg := t.Obj().Pkg()
		if pkg != nil && pkg.Path() != g.pkg.Path() {
			g.imports[pkg.Path()] = pkg
			name += pkg.Name() + "."
		}
		name += t.Obj().Name()
		g.typNow = name
		return name
	case *types.Array:
		typ := g.zero(t.Elem())
		out := fmt.Sprintf("[%d]%s", t.Len(), typ)
		g.typNow = out
		return out
	case *types.Pointer:
		out := "(*" + g.zero(t.Elem()) + ")"
		g.typNow = out
		return out
	case *types.Struct:
		out := "struct{"
		for i := 0; i < t.NumFields(); i++ {
			f := t.Field(i)
			name, typ := g._var(f)
			out += fmt.Sprintf("%s %s;", name, typ)
		}
		out += "}"
		g.typNow = out
		return out
	case *types.Signature:
		out := fmt.Sprintf("func %s %s", g.tuple(t.Params()), g.tuple(t.Results()))
		g.typNow = out
		return out
	case *types.Slice:
		out := "[]" + g.zero(t.Elem())
		g.typNow = out
		return out
	case *types.Map:
		k := g.zero(t.Key())
		v := g.zero(t.Elem())
		out := fmt.Sprintf("map[%s]%s", k, v)
		g.typNow = out
		return out
	case *types.Interface:
		out := "interface{"
		for i := 0; i < t.NumEmbeddeds(); i++ {
			out += g.zero(t.EmbeddedType(i)) + ";"
		}
		for i := 0; i < t.NumExplicitMethods(); i++ {
			m := t.ExplicitMethod(i)
			typ := g.zero(m.Type())
			method := m.Name() + typ[len("func"):]
			out += method + ";"
		}
		out += "}"
		g.typNow = out
		return out
	case *types.Chan:
		out := "chan"
		switch t.Dir() {
		case types.SendOnly:
			out += "<-"
		case types.RecvOnly:
			out = "<-" + out
		default:
		}
		out += " " + g.zero(t.Elem())
		g.typNow = out
		return out
	default:
	}
	return "nil"
}

func (g *Generator) _var(v *types.Var) (name string, typ string) {
	return v.Name(), g.zero(v.Type())
}

func (g *Generator) tuple(t *types.Tuple) string {
	out := "("
	for i := 0; i < t.Len(); i++ {
		f := t.At(i)
		n, typ := g._var(f)
		out += fmt.Sprintf("%s %s,", n, typ)
	}
	out += ")"
	return out
}
